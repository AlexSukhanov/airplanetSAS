(function() {
  var expect;

  expect = require("chai").expect;

  describe("Injector function call tests", function() {
    var InjectCall, injectObj;
    InjectCall = require("../../src/call");
    injectObj = null;
    beforeEach(function() {
      return injectObj = new InjectCall(["test", "test2"], (function(t1, t2) {
        return [t1, t2];
      }), {
        "test": "Hello",
        "test2": "World"
      });
    });
    afterEach(function() {
      return injectObj = null;
    });
    describe("Calling injectCall as it is", function() {
      return it("Should be Hello World", function() {
        var result;
        result = injectObj.invoke();
        return expect(result).eql(["Hello", "World"]);
      });
    });
    return describe("Calling injectCall with injection factor", function() {
      var factor;
      factor = void 0;
      beforeEach(function() {
        return factor = {
          "test": "Helo",
          "test2": "Konichiwa"
        };
      });
      it("Should be Helo Konichiwa", function() {
        return expect(injectObj.invoke(factor)).eql(["Helo", "Konichiwa"]);
      });
      describe("If the factor lacks something...", function() {
        beforeEach(function() {
          return delete factor.test;
        });
        return it("Should be Hello Konichiwa", function() {
          return expect(injectObj.invoke(factor)).eql(["Hello", "Konichiwa"]);
        });
      });
      return describe("If the factor has an extra element", function() {
        it("Shouldn't throw any errors", function() {
          return expect(function() {
            return injectObj.invoke(factor);
          }).not["throw"](Error);
        });
        return it("Should be Helo Konichiwa", function() {
          return expect(injectObj.invoke(factor)).eql(["Helo", "Konichiwa"]);
        });
      });
    });
  });

}).call(this);
