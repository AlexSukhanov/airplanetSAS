(function() {
  var expect, fs, g, gutil, os, path, q, removeMapFile, rm;

  expect = require("chai").expect;

  fs = require("fs");

  q = require("q");

  g = require("gulp");

  gutil = require("gulp-util");

  removeMapFile = require("convert-source-map").removeMapFileComments;

  path = require("path");

  rm = require("rimraf");

  os = require("os");

  describe("SCSS integration tests", function() {
    var options, scss, sourcemaps;
    scss = void 0;
    sourcemaps = void 0;
    options = {
      "bundleExec": true
    };
    before(function(done) {
      return rm("./tests/results", done);
    });
    beforeEach(function() {
      sourcemaps = require("gulp-sourcemaps");
      return scss = require("../src/scss");
    });
    afterEach(function() {
      delete require.cache[require.resolve("gulp-sourcemaps")];
      return delete require.cache[require.resolve("../src/scss.coffee")];
    });
    describe("Single File Case", function() {
      var right;
      right = {};
      before(function(done) {
        var targetPromises;
        targetPromises = [
          q.nfcall(fs.readFile, "./tests/data/single/source.css").then(function(css) {
            return right.file = removeMapFile(css.toString("utf-8")).trim();
          }), q.nfcall(fs.readFile, "./tests/data/single/source.css.map").then(function(sourcemap) {
            right.sourcemap = JSON.parse(sourcemap.toString("utf-8"));
            return right.sourcemap.sources = right.sourcemap.sources.map(function(file) {
              return path.relative(process.cwd(), path.resolve("./tests/data/single", file)).replace(/\\/g, "/");
            });
          })
        ];
        return q.all(targetPromises).done((function() {
          return done();
        }), done);
      });
      return it("The file should be compiled properly", function(done) {
        var compilationDefer;
        compilationDefer = q.defer();
        g.src("./tests/data/single/source.scss").pipe(sourcemaps.init()).pipe(scss(options)).pipe(sourcemaps.write("./", {
          "includeContent": false
        })).pipe(g.dest("./tests/results/single")).once("end", compilationDefer.resolve).once("error", function(e) {
          compilationDefer.reject(e);
          throw e;
        });
        return compilationDefer.promise.then(function() {
          return q.all([q.nfcall(fs.readFile, "./tests/results/single/source.css"), q.nfcall(fs.readFile, "./tests/results/single/source.css.map")]).then(function(data) {
            expect(removeMapFile(data[0].toString("utf-8")).trim()).equal(right.file);
            return expect(JSON.parse(data[1])).eql(right.sourcemap);
          });
        }).done((function() {
          return done();
        }), done);
      });
    });
    describe("Multiple Files Case", function() {
      var right, targetFiles;
      this.timeout(30000);
      right = {};
      targetFiles = ["test1.css", "test2.css", "test3.css"];
      before(function(done) {
        var promises;
        promises = [];
        targetFiles.forEach(function(file) {
          promises.push(q.nfcall(fs.readFile, path.join("./tests/data/multiple", file)).then(function(data) {
            var resultPath;
            resultPath = path.join("./tests/results/multiple", file);
            if (!right[resultPath]) {
              right[resultPath] = {};
            }
            return right[resultPath].content = removeMapFile(data.toString("utf-8")).trim();
          }));
          return promises.push(q.nfcall(fs.readFile, path.join("./tests/data/multiple", file + ".map")).then(function(data) {
            var resultPath;
            resultPath = path.join("./tests/results/multiple", file);
            if (!right[resultPath]) {
              right[resultPath] = {};
            }
            right[resultPath].sourcemap = JSON.parse(data);
            return right[resultPath].sourcemap.sources = right[resultPath].sourcemap.sources.map(function(file) {
              return path.relative(process.cwd(), path.resolve("./tests/data/multiple", file)).replace(/\\/g, "/");
            });
          }));
        });
        return q.all(promises).then(function() {
          return done();
        })["catch"](done);
      });
      return it("The files should be compiled properly", function(done) {
        var defer, file, sources;
        defer = q.defer();
        sources = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = targetFiles.length; i < len; i++) {
            file = targetFiles[i];
            results.push(path.join("./tests/data/multiple", gutil.replaceExtension(file, ".scss")));
          }
          return results;
        })();
        g.src(sources).pipe(sourcemaps.init()).pipe(scss(options)).pipe(sourcemaps.write("./", {
          "includeContent": false
        })).pipe(g.dest("./tests/results/multiple")).on("end", defer.resolve).once("error", defer.reject);
        return defer.promise.then(function() {
          var files, promises;
          files = targetFiles.map(function(file) {
            return path.join("./tests/results/multiple", file);
          });
          promises = [];
          files.forEach(function(file) {
            promises.push(q.nfcall(fs.readFile, file).then(function(data) {
              return expect(removeMapFile(data.toString("utf-8")).trim()).equal(right[file].content);
            }));
            return promises.push(q.nfcall(fs.readFile, file + ".map").then(function(data) {
              return expect(JSON.parse(data)).eql(right[file].sourcemap);
            }));
          });
          return q.all(promises).done((function() {
            return done();
          }), done);
        });
      });
    });
    describe("Glob test case", function() {
      var folders, right;
      this.timeout(30000);
      right = {};
      folders = ["test1", "test2", "test3"];
      before(function(done) {
        var promises;
        promises = [];
        folders.forEach(function(folder) {
          var result_path;
          result_path = path.join("tests/results/glob", folder, "source.css");
          return promises.push(q.nfcall(fs.readFile, path.join("./tests/data/glob", folder, "source.css")).then(function(data) {
            if (!right[result_path]) {
              right[result_path] = {};
            }
            return right[result_path].content = removeMapFile(data.toString("utf-8")).trim();
          }), q.nfcall(fs.readFile, path.join("./tests/data/glob", folder, "source.css.map")).then(function(data) {
            if (!right[result_path]) {
              right[result_path] = {};
            }
            right[result_path].map = JSON.parse(data);
            delete right[result_path].map.file;
            return right[result_path].map.sources = right[result_path].map.sources.map(function(file) {
              return path.relative(process.cwd(), path.resolve(path.join("./tests/data/glob", folder), file)).replace(/\\/g, "/");
            });
          }));
        });
        return q.all(promises).done((function() {
          return done();
        }), done);
      });
      return it("The files should be compiled properly", function(done) {
        var defer;
        defer = q.defer();
        g.src("./tests/data/glob/**/*.scss").pipe(sourcemaps.init()).pipe(scss(options)).pipe(sourcemaps.write("./", {
          "includeContent": false
        })).pipe(g.dest("./tests/results/glob")).once("end", defer.resolve).once("error", defer.reject);
        return defer.promise.then(function() {
          var promises;
          promises = [];
          folders.forEach(function(folder) {
            var resultPath;
            resultPath = path.join("./tests/results/glob", folder, "source.css");
            promises.push(q.nfcall(fs.readFile, resultPath).then(function(data) {
              return expect(removeMapFile(data.toString("utf-8")).trim()).equal(right[resultPath].content);
            }));
            return promises.push(q.nfcall(fs.readFile, resultPath + ".map").then(function(map) {
              var sourcemap;
              sourcemap = JSON.parse(map);
              delete sourcemap.file;
              return expect(sourcemap).eql(right[resultPath].map);
            }));
          });
          return q.all(promises);
        }).done((function() {
          return done();
        }), done);
      });
    });
    return describe("Import test case", function() {
      var right;
      right = {};
      beforeEach(function(done) {
        var promises;
        promises = [
          q.nfcall(fs.readFile, "./tests/data/imports/main.css").then(function(data) {
            return right.content = removeMapFile(data.toString("utf-8")).trim();
          }), q.nfcall(fs.readFile, "./tests/data/imports/main.css.map").then(function(data) {
            right.map = JSON.parse(data);
            return right.map.sources = right.map.sources.map(function(file) {
              return path.relative(process.cwd(), path.resolve("./tests/data/imports", file)).replace(/\\/g, "/");
            });
          })
        ];
        return q.all(promises).done((function() {
          return done();
        }), done);
      });
      return it("The code should be compiled properly", function(done) {
        var defer;
        defer = q.defer();
        g.src("./tests/data/imports/main.scss").pipe(sourcemaps.init()).pipe(scss(options)).pipe(sourcemaps.write("./", {
          "includeContent": false
        })).pipe(g.dest("./tests/results/imports")).once("end", defer.resolve).once("error", defer.reject);
        return defer.promise.then(function() {
          var promises;
          promises = [];
          promises.push(q.nfcall(fs.readFile, "./tests/results/imports/main.css").then(function(data) {
            return expect(removeMapFile(data.toString("utf-8")).trim()).equal(right.content);
          }));
          promises.push(q.nfcall(fs.readFile, "./tests/results/imports/main.css.map").then(function(data) {
            return expect(JSON.parse(data)).eql(right.map);
          }));
          return q.all(promises);
        }).done((function() {
          return done();
        }), done);
      });
    });
  });

}).call(this);
