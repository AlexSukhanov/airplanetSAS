(function() {
  var expect, extend, gutil, path, sinon, through2;

  expect = require("chai").expect;

  sinon = require("sinon");

  through2 = require("through2");

  path = require("path");

  extend = require("extend");

  gutil = require("gulp-util");

  describe("SCSS unit test", function() {
    var cb, file, fs, func_scss, ioMap, objectToInject, scss;
    objectToInject = void 0;
    scss = void 0;
    file = void 0;
    fs = void 0;
    func_scss = void 0;
    cb = void 0;
    ioMap = void 0;
    beforeEach(function() {
      var dest;
      delete process.env.testing;
      delete require.cache[require.resolve("../src/scss.coffee")];
      process.env.testing = true;
      scss = require("../src/scss.coffee");
      dest = sinon.spy();
      cb = sinon.spy();
      file = {
        "clone": sinon.stub().returns(extend(true, file)),
        "isNull": sinon.stub().returns(false),
        "isBuffer": sinon.stub().returns(true),
        "isStream": sinon.stub().returns(false),
        "pipe": sinon.spy(),
        "path": path.join(path.sep, "tests", "data", "source.scss"),
        "cwd": path.sep,
        "base": path.join(path.sep, "tests", "data"),
        "contents": new Buffer("Hello World"),
        "relative": "source.scss"
      };
      objectToInject = {
        "exec": sinon.stub().returns({
          "on": function(event, callback) {
            if (event === "close") {
              return callback(0);
            }
          }
        }),
        "fs": {
          "createWriteStream": sinon.stub().returns({
            "on": function(event, callback) {
              if (event === "finish") {
                return callback();
              }
            }
          }),
          "readFile": function(path, options, cb) {
            if (typeof options === "function") {
              return options(void 0, file.contents);
            }
            return cb(void 0, file.contents);
          }
        },
        "mkdirp": sinon.stub().callsArg(1)
      };
      return func_scss = scss.__compile__.invoke(objectToInject);
    });
    describe("Null File", function() {
      beforeEach(function() {
        file.isNull = sinon.stub().returns(true);
        return file.isBuffer = sinon.stub().returns(false);
      });
      return it("cb should be called", function() {
        func_scss()(file, void 0, cb);
        return expect(cb.calledWith(null, file)).is.ok;
      });
    });
    describe("Non Null File", function() {
      beforeEach(function() {
        return file.isNull = sinon.stub().returns(false);
      });
      return it("cb should returns as it is", function(done) {
        return func_scss()(file, void 0, cb).then(function() {
          return expect(cb.calledWith(null, file)).is.ok;
        }).done((function() {
          return done();
        }), done);
      });
    });
    describe("When options are passed", function() {
      describe("When bundleExec is true", function() {
        var func_promise;
        func_promise = void 0;
        beforeEach(function(done) {
          return func_promise = func_scss({
            "bundleExec": true
          })(file, void 0, function() {
            return done();
          });
        });
        it("exec function should be called with bundle exec scss", function(done) {
          return func_promise.then(function() {
            expect(objectToInject.exec.calledWithExactly("bundle", ["exec", "scss", "--sourcemap=auto", gutil.replaceExtension(file.path, ".scss"), path.join(file.cwd, ".gulp-scss-cache", path.relative(file.cwd, file.base), "source.css")], {
              "stdio": "inherit",
              "shell": true
            })).is["true"];
            return done();
          })["catch"](done);
        });
        return it("file path should be replaced with .gulp-scss-cache/source.css", function(done) {
          return func_promise.then(function() {
            return expect(file.path).equal(path.join(path.sep + "tests", "data", "source.css"));
          }).done((function() {
            return done();
          }), done);
        });
      });
      describe("When bundleExec is false", function() {
        var func_promise;
        func_promise = void 0;
        beforeEach(function(done) {
          return func_promise = func_scss({
            "bundleExec": false
          })(file, void 0, (function() {
            return done();
          }));
        });
        it("exec function should be called with scss", function(done) {
          return func_promise.then(function() {
            return expect(objectToInject.exec.calledWithExactly("scss", ["--sourcemap=auto", gutil.replaceExtension(file.path, ".scss"), path.join(file.cwd, ".gulp-scss-cache", path.relative(file.cwd, file.base), "source.css")], {
              "stdio": "inherit",
              "shell": true
            })).is["true"];
          }).done((function() {
            return done();
          }), done);
        });
        return it("Path should have css extension", function() {
          return expect(file.path).is.equal(path.join(path.sep + "tests", "data", "source.css"));
        });
      });
      describe("When path is specified", function() {
        var func_promise;
        func_promise = void 0;
        beforeEach(function(done) {
          return func_promise = func_scss({
            "tmpPath": "test"
          })(file, void 0, (function() {
            return done();
          }));
        });
        return it("Dir named \"test\" should be created", function(done) {
          return func_promise.then(function() {
            return expect(objectToInject.mkdirp.calledWith(path.join(file.cwd, "test", path.relative(file.cwd, file.base)))).is.ok;
          }).done((function() {
            return done();
          }), done);
        });
      });
      return describe("When sourcemap has special options", function() {
        var i, len, ref, results, smvalue;
        ref = ["auto", "file", "inline", "none"];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          smvalue = ref[i];
          results.push((function(smvalue) {
            return describe("Case: " + smvalue, function() {
              var func_promise;
              func_promise = void 0;
              beforeEach(function(done) {
                return func_promise = func_scss({
                  "sourcemap": smvalue
                })(file, void 0, (function() {
                  return done();
                }));
              });
              return it("exec function should be called with sourcemap", function(done) {
                return func_promise.then(function() {
                  return expect(objectToInject.exec.calledWithExactly("scss", ["--sourcemap=" + smvalue, gutil.replaceExtension(file.path, ".scss"), path.join(file.cwd, ".gulp-scss-cache", path.relative(file.cwd, file.base), "source.css")], {
                    "stdio": "inherit",
                    "shell": true
                  })).is["true"];
                }).done((function() {
                  return done();
                }), done);
              });
            });
          })(smvalue));
        }
        return results;
      });
    });
    return describe("Without any options", function() {
      var func_promise;
      func_promise = void 0;
      beforeEach(function(done) {
        return func_promise = func_scss()(file, void 0, (function() {
          return done();
        }));
      });
      it("exec function should be called with scss", function(done) {
        return func_promise.then(function() {
          return expect(objectToInject.exec.calledWithExactly("scss", ["--sourcemap=auto", gutil.replaceExtension(file.path, ".scss"), path.join(file.cwd, ".gulp-scss-cache", path.relative(file.cwd, file.base), "source.css")], {
            "stdio": "inherit",
            "shell": true
          })).is.ok;
        }).done((function() {
          return done();
        }), done);
      });
      return it("Path should have css extension", function() {
        return expect(file.path).is.equal(path.join(path.sep + "tests", "data", "source.css"));
      });
    });
  });

  describe("For non-testing mode", function() {
    after(function() {
      return delete require.cache[require.resolve("../src/scss.coffee")];
    });
    return it("The plugin should be a function", function() {
      return expect(require("../src/scss.coffee")).is.a("function");
    });
  });

}).call(this);
